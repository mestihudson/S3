# S3 connector

S3 handles the requests coming from S3 clients. It is based on the
current amazon-S3 documentation.

## Implementation

### Architecture

S3 consists of multiple daemons listening RESTfully to http requests
on a single port. We then route the requests depending on the HTTP verbs
used by the request. Parsing the header allows us to determine the request
type. From there, authentication will be confirmed
by the Vault module using v2 or v4 authentication depending on whether the
client sent a v2 or v4 authentication header. Applicable bucket and object
metadata will be pulled from the metadata backend, IM-Metadata to check proper
authorization (ACL's, IAM and bucket policies). If a user has been
authenticated and is authorized to write/read data, we then proceed to
send the write/read request to our storage backend (RING or IM-Data), before
sending a response to the request sender. Any problem that arises during
the handling of the request due to client error or system error will result
in an error being returned to the client that follows S3's error specifications.

The multi-daemon architecture allows us to restart daemons on the fly in case
of any crash without interrupting the service. The daemon handles
remaining requests even in case of an error, stopping listening while another
daemon is spawned to handle future requests in its stead.

![Arch](res/architecture.png)

## Versioning

This section describes S3 Server's support for the specific AWS S3 Bucket
Versioning feature.

### AWS S3 Bucket Versioning

An object in a versioning enabled bucket can have multiple versions, whereas an
object can have only a single version in a standard bucket without versioning.

With the standard S3 API, any update (PUT, DELETE) to an object in a versioning
enabled bucket would create a new version of that object. Read operations such
as GET and LIST would see the latest version of the objects. The table below
shows such example, a `PUT foo` generates a new version `v2` and keeps `v1`;
GET and LIST return the latest version of `foo`, which is `v2` in this case.

| key | version | value |
|-----|:-------:|:-----:|
| foo |   v2    |   A   |
| foo |   v1    |   B   |

To work with all existing versions of the objects, S3 provides an extended
API which uses the same operations of the standard API, but with versioning
information specified. For example, in order to get the version `v1` of `foo`,
users have to specify that version in the query, such as
`GET /foo?versionId=v1`.

A bucket can be non-versioning or versioning. The version of the objects of a
bucket before it was versioning-enabled are called the "null" version; these
versions are kept when a bucket is versioning enabled and are identified with
the version identifier as "null". Turning off the versioning of a bucket would
make all operations target the "null" versions of the objects, but would not
delete all existing versions.

### Implementation of Bucket Versioning in S3

Each version of an object is stored as a separate key in metadata that
corresponds to the data of the version in the datastore. The API component of
S3 manages the putting and delete of version data, sends instructions to create,
retrieve, overwrite or delete a version's metadata to the metadata backend, and
tracks extra information about a version, such as whether it is a delete marker
or a null version.

The metadata backend is responsible for handling the create, overwrite and
delete operations of version metadata upon receiving instructions. We use
version identifiers as the suffix for the keys of the object versions, and a
special version to represent the latest version.

The following is a summary of the design and details of implementation of
versioning in S3.

#### Version Id Format

The version id is generated by the metadata backend, and encoded in a
hexadecimal string format by S3. The following information is encoded in a
version ID:

`object_name separator version_id`
where:

- `object_name`: is the key of the object in metadata
- `separator`: we use the `null` character (`0x00` or `\0`) as the separator
  between the `object_name` and the `version_id` of a key
- `version_id`: is the version identifier; this encodes the ordering
  information in the texture format as metadata orders keys alphabetically

#### Master Version

We store a copy of the latest version of an object's metadata using
`object_name` as the key; this version is called the master version. The master
versions of the objects facilitate the standard GET operation, which would
otherwise need to scan among the list of versions of an object for its latest
version.

The following table shows the layout of all versions of `foo` in the previous
example stored in the metadata (with dot `.` representing the null separator):

| key | value |
|-----|:-----:|
| foo |   A   |
| foo.v2 |   A   |
| foo.v1 |   B   |

#### Metadata Versioning Options

S3 Server sends instructions to the metadata engine about whether to create a
new version or overwrite, retrieve, or delete a specific version by sending
values for special options in PUT, GET, or DELETE calls to metadata.

Note: all operations (PUT and DELETE) that generate a new version of an object
will return the `version_id` of the new version to the API.

##### PUT

- no options: original PUT operation, will update the master version
- `versioning: true` create a new version of the object,
  then update the master version with this version.
- `versionId: <versionId>` update a specific version (for updating version's ACL
  or remote updates in geo-replication);
  - if the version identified by `versionId` happens to be the latest version,
    the master version will be updated as well
  - note that with `versionId` set to an empty string `''`, it will overwrite
    the master version only (same as no options, but returns a version ID)

##### DELETE

-  no options: original DELETE operation, will delete the master version
- `versionId: <versionId>` delete a specific version

Version-specific deletions involve a few steps. A deletion targeting the latest
version of an object has to:

- delete the specified version identified by `versionId`
- replace the master version with a place holder for deletion version
- initiate a repair operation to update the value of the master version:
  - involves listing the versions of the object and get the latest
  version to replace the place holder delete version
  - if no more versions exists, metadata deletes the master version

##### GET

-  no options: original DELETE operation, will get the master version
- `versionId: <versionId>` retrieve a specific version

The implementation of a GET operation does not change compared to the standard
version. A standard GET without versioning information would get the master
version of a key. A version-specific GET would retrieve the specific version
identified by the key for that version.

##### LIST

For a standard LIST on a bucket, metadata iterates through the keys by using
the separator `.` as an extra delimiter. For a listing of all versions of a
bucket, there is no change compared to the original listing function. Instead,
the API component returns all the keys in a List Objects call and filters for
just the keys of the master versions in a List Object Versions call.

For example, a standard LIST operation against the keys in a table below would
return from metadata the list of `[ foo/bar, bar, qux/quz, quz ]` using the
separator represented by `.` as the extra delimiter.

| key |
|-----|
| foo/bar |
| foo/bar.v2 |
| foo/bar.v1 |
| bar |
| qux/quz |
| qux/quz.v2 |
| qux/quz.v1 |
| quz |
| quz.v2 |
| quz.v1 |

#### Delete Markers

In buckets that have been configured for versioning, the Delete Object API
action will not result in the deletion of an object or version unless a specific
version ID is provided in the request query, e.g. `DELETE /foo?versionId=v1`.

If no version ID is provided, a special version called a delete marker is
created. When performing actions upon an object whose latest version is a delete
maker, the S3 API will return a 404 NoSuchKey error and behave as if that object
has been deleted. To restore a previous version as the latest version of an
object, the delete marker must be deleted, by the same process as deleting any
other version.

The metadata engine's versioning processing is agnostic to whether a specific
version is a delete marker. The S3 API stores information about whether
a version is a delete marker in its metadata and performs a check to retrieve
that information.

#### Null Version Mapping

Null versions are created when versioning has not been enabled or when
versioning is suspended. Previous null versions are overwritten by new null
versions. Within metadata, this means the null version is stored by overwriting
the master version only, instead of overwriting the master version and
generating a new version.

When a new version is put once versioning has been enabled or re-enabled, the
the S3 API stores the current null version as a new version prior to overwriting
the master version.

The S3 API identifies the current null version by the version id "null".
Therefore, the API stores information about whether a version is a null version
and the current null version's internal version id, used by the metadata engine,
in each version's metadata to be able to retrieve the correct version when the
null version is identified.

### API specifications

Right now, the following operations are implemented:

- PutBucket
- GetBucket
- HeadBucket
- DeleteBucket
- PutBucketACL
- GetBucketACL
- PutBucketCors
- DeleteBucketCors
- GetBucketCors
- PutObject
- PutObject - Copy
- GetObject
- HeadObject
- DeleteObject
- Multi-Object Delete
- PutObjectACL
- GetObjectACL
- Multipart Upload
- Upload Part
- Upload Part - Copy
- GetService
- Put Bucket Website
- Get Bucket Website
- Delete Bucket Website
- v2 Authentication
- v4 Authentication (Transferring Payload in a Single Chunk)
- v4 Authentication (Transferring Payload in Multiple Chunks)
