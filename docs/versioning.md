# Versioning

This section describes S3 Server's support for the specific AWS S3 Bucket
Versioning feature.

## AWS S3 Bucket Versioning

An object in a versioning enabled bucket can have multiple versions, whereas an
object can have only a single version in a standard bucket without versioning.

With the standard S3 API, any update (PUT, DELETE) to an object in a versioning
enabled bucket would create a new version of that object. Read operations such
as GET and LIST would see the latest version of the objects. The table below
shows such example, a `PUT foo` generates a new version `v2` and keeps `v1`;
GET and LIST return the latest version of `foo`, which is `v2` in this case.

| key | version | value |
|-----|:-------:|:-----:|
| foo |   v2    |   A   |
| foo |   v1    |   B   |

To work with all existing versions of an object, S3 provides an extended
API which uses the same operations of the standard API, but with versioning
information specified. For example, in order to get the version `v1` of `foo`,
users have to specify that version in the query, such as
`GET /foo?versionId=v1`.

A bucket can be non-versioning or versioning. Any objects placed in a bucket
before versioning is enabled are considered to be the "null" version. When
versioning is enabled, the "null" version will be kept and continue to be
identified as the "null" version. However, if versioning is suspended, the
"null" version may be overwritten with a new "null" version. All versions with
a version ID other than "null" are retained when versioning is suspended, even
when there are new puts on the object.

## Implementation of Bucket Versioning in S3

Each version of an object is stored as a separate key in metadata. The API
component of S3 manages the put and delete of version data, sends instructions
to create, retrieve, overwrite or delete a version's metadata to the metadata
backend, and tracks extra information about a version, such as whether it is a
delete marker or a null version.

The metadata backend is responsible for handling the create, overwrite and
delete operations of version metadata upon receiving instructions. We use
version identifiers as the suffix for the keys of the object versions, and a
special version to represent the latest version. An example of what these
keys may look like in metadata, for an object `foo/bar` with three versions:

| key |
|-----|
| foo/bar |
| foo/bar\098506163554375999999PARIS  0.a430a1f85c6ec |
| foo/bar\098506163554373999999PARIS  0.41b510cd0fdf8 |
| foo/bar\098506163554373999998PARIS  0.f9b82c166f695 |

The following is a summary of the design and details of implementation of
versioning in S3.

### Version Id Format

The version id is generated by the metadata backend, and encoded in a
hexadecimal string format by S3. The following information is encoded before
sending out in response to a request. S3 also decodes the hexadecimal string
received from a request before sending to metadata to retrieve a particular
version.

`object_name separator version_id`
where:

- `object_name`: is the key of the object in metadata
- `separator`: we use the `null` character (`0x00` or `\0`) as the separator
  between the `object_name` and the `version_id` of a key
- `version_id`: is the version identifier; this encodes the ordering
  information in the texture format as metadata orders keys alphabetically

The format of a `version_id` is: `ts` `rep_group_id` `seq_id`; `ts` is the
combination of epoch and an increasing number, `rep_group_id` is the name of
data center or a site (or a region AWS equivalently) used for replication later,
and `seq_id` is supposed to be a unique value based on metadata information.

An example of a key: `foo\01234567890123456PARIS 1234.123456` indicating that
this specific version of `foo` was the `123456`th entry created during the epoch
`1234567890` in the replication group `PARIS` with `1234.1234566` as `seq_id`.

### Master Version

We store a copy of the latest version of an object's metadata using
`object_name` as the key; this version is called the master version. The master
versions of the objects facilitate the standard GET operation, which would
otherwise need to scan among the list of versions of an object for its latest
version.

The following table shows the layout of all versions of `foo` in the first
example stored in the metadata (with dot `.` representing the null separator):

| key | value |
|-----|:-----:|
| foo |   A   |
| foo.v2 |   A   |
| foo.v1 |   B   |

### Metadata Versioning Options

S3 Server sends instructions to the metadata engine about whether to create a
new version or overwrite, retrieve, or delete a specific version by sending
values for special options in PUT, GET, or DELETE calls to metadata.

Note: all operations (PUT and DELETE) that generate a new version of an object
will return the `version_id` of the new version to the API.

#### PUT

- no options: original PUT operation, will update the master version
- `versioning: true` create a new version of the object,
  then update the master version with this version.
- `versionId: <versionId>` update a specific version (for updating version's ACL
  or remote updates in geo-replication);
  - if the version identified by `versionId` happens to be the latest version,
    the master version will be updated as well
  - note that with `versionId` set to an empty string `''`, it will overwrite
    the master version only (same as no options, but returns a version ID)

#### DELETE

-  no options: original DELETE operation, will delete the master version
- `versionId: <versionId>` delete a specific version

Version-specific deletions involve a few steps. A deletion targeting the latest
version of an object has to:

- delete the specified version identified by `versionId`
- replace the master version with a version that is a placeholder for deletion
  - this version contains a special keyword, 'isPHD', to indicate the master
  version was deleted and needs to be updated
- initiate a repair operation to update the value of the master version:
  - involves listing the versions of the object and get the latest
  version to replace the place holder delete version
  - if no more versions exists, metadata deletes the master version, removing
  the key from metadata

Note: all of this happens before responding to S3, and only when the metadata
engine is instructed by S3 to delete a specific version or the master version.
See section "Delete Markers" for a description of what happens when a delete
object request is sent to the S3 API.

#### GET

-  no options: original GET operation, will get the master version
- `versionId: <versionId>` retrieve a specific version

The implementation of a GET operation does not change compared to the standard
version. A standard GET without versioning information would get the master
version of a key. A version-specific GET would retrieve the specific version
identified by the key for that version.

#### LIST

For a standard LIST on a bucket, metadata iterates through the keys by using
the separator represented by `.` as an extra delimiter. For a listing of all
versions of a bucket, there is no change compared to the original listing
function. Instead, the API component returns all the keys in a List Objects call
and filters for just the keys of the master versions in a List Object Versions
call.

For example, a standard LIST operation against the keys in a table below would
return from metadata the list of `[ foo/bar, bar, qux/quz, quz ]` using the
separator represented by `.` as the extra delimiter.

| key |
|-----|
| foo/bar |
| foo/bar.v2 |
| foo/bar.v1 |
| bar |
| qux/quz |
| qux/quz.v2 |
| qux/quz.v1 |
| quz |
| quz.v2 |
| quz.v1 |

### Delete Markers

In buckets that have been configured for versioning, the Delete Object API
action will not result in the deletion of an object or version unless a specific
version ID is provided in the request query, e.g. `DELETE /foo?versionId=v1`.

If no version ID is provided, a special version called a delete marker is
created. When getting an object whose latest version is a delete
maker, the S3 API will return a 404 NoSuchKey error and behave as if that object
has been deleted. To restore a previous version as the latest version of an
object, the delete marker must be deleted, by the same process as deleting any
other version.

The metadata engine's versioning processing is agnostic to whether a specific
version is a delete marker. Instead, the S3 API stores information about whether
a version is a delete marker in its metadata and checks the object's metadata
to determine whether a version is a delete marker.

The following steps are used in the delete logic for delete marker creation:
- if versioning has not been configured: attempt to delete the object
- if request is version-specific delete request: attempt to delete the version
- otherwise, if not a version-specific delete request and versioning has been
configured:
    - create a new 0-byte content-length version
    - in version's metadata, set a 'isDeleteMarker' property to true
- return the version ID of any version deleted or any delete marker created
- set response header 'x-amz-delete-marker' to true if a delete marker
  was deleted or created

The Multi-Object Delete API follows the same logic for each of the objects or
versions listed in an xml request. Note that a delete request can result in
the creation of a deletion marker even if the object requested to delete does
not exist in the first place.

Object-level APIs which can target existing objects and versions perform the
following checks regarding delete markers:
- If not a version-specific request and versioning has been configured, check
the metadata of the latest version
  - If the 'isDeleteMarker' property is set to true, return 404 NoSuchKey
  (for cases like Get Object or Get Object ACL) or 405 MethodNotAllowed
  (Put Object ACL, Put Object Tagging)
- If it is a version-specific request, check the metadata of the requested
version
- If the 'isDeleteMarker' property is set to true, return 405 MethodNotAllowed

### Null Version Management and Mapping

Null versions are created when versioning has not been enabled or when
versioning has been suspended. Previous null versions are overwritten by new
null versions. Within metadata, this means the null version is initially stored
in the master version only, instead of generating a new version and updating
the master version. The tables below show the keys in metadata if we put an
object 'foo' twice, when versioning has not been enabled or is suspended.

(1) PUT foo (first put)

| key | value |
|-----|:-----:|
| foo (null) |   A   |

(2) PUT foo (second put)

| key | value |
|-----|:-----:|
| foo (null) |   B   |

However, null versions are preserved when versioning has been enabled or
re-enabled and new versions are created. To preserve the null version, the
the S3 API stores the current null version as a new version prior to overwriting
the master version. This means that the null version may not be the latest
version. To continue the above example, if we enabled versioning and put another
version, the metadata keys would resemble the following:

(3) PUT foo

| key | value |
|-----|:-----:|
| foo |   C   |
| foo.v2 |   C   |
| foo.v1 (null) |   B   |

In the case versioning is suspended and the null version is not the latest
version, the S3 API sends a delete instruction to metadata to delete the
current null version when creating a new null version.

(4A) PUT foo

| key | value |
|-----|:-----:|
| foo |   C   |
| foo.v2 |   C   |

Then the master version is overwritten with the new null version:

(4B) PUT foo

| key | value |
|-----|:-----:|
| foo (null) |   D   |
| foo.v2 |   C   |

The API tracks and stores information about whether a version is a null
version in in each version's metadata. Furthermore, the S3 API externally
identifies the current null version by the version id "null". Therefore, the API
stores the current null version's internal version id, used by the metadata
engine, in each version's metadata to be able to retrieve the correct version
when the null version is requested.
